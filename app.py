# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oSpQrI7_QcZLBd1ttPsi6MkCSXCT6k5x
"""

# 1. Install Streamlit and pyngrok
!pip install streamlit pyngrok --quiet

# 2. Write your Streamlit app code into 'app.py'
streamlit_app = '''
import streamlit as st
import pandas as pd
import numpy as np
import torch
import torch.nn as nn
import torch.optim as optim
from sklearn.preprocessing import StandardScaler
from sklearn.metrics.pairwise import cosine_similarity

# Set up Streamlit page
st.set_page_config(page_title="Meal Plan Generator üçõ", layout="wide")

# --- Load data ---
@st.cache_data
def load_data():
    df = pd.read_csv('/content/gh_food_nutritional_values.csv')
    df['Food'] = df['Food'].str.strip().str.lower()
    cols = ['Protein(g)', 'Fat(g)', 'Carbs(g)', 'Calories(100g)', 'Water(g)', 'SFA(100g)', 'MUFA(100g)', 'PUFA(100g)']
    df[cols] = df[cols].fillna(df[cols].mean())
    return df, cols

df, nutritional_columns = load_data()

# --- Model ---
class FoodAutoencoder(nn.Module):
    def __init__(self, input_dim, embedding_dim=16):
        super(FoodAutoencoder, self).__init__()
        self.encoder = nn.Sequential(
            nn.Linear(input_dim, 32),
            nn.ReLU(),
            nn.Linear(32, embedding_dim)
        )
        self.decoder = nn.Sequential(
            nn.Linear(embedding_dim, 32),
            nn.ReLU(),
            nn.Linear(32, input_dim)
        )
    def forward(self, x):
        encoded = self.encoder(x)
        decoded = self.decoder(encoded)
        return encoded, decoded

@st.cache_resource
def train_model(X):
    model = FoodAutoencoder(input_dim=X.shape[1])
    optimizer = optim.Adam(model.parameters(), lr=0.001)
    criterion = nn.MSELoss()
    X_tensor = torch.tensor(X, dtype=torch.float32)
    for epoch in range(300):
        optimizer.zero_grad()
        embeddings, outputs = model(X_tensor)
        loss = criterion(outputs, X_tensor)
        loss.backward()
        optimizer.step()
    with torch.no_grad():
        food_embeddings = model.encoder(X_tensor).numpy()
    return food_embeddings

# Normalize
scaler = StandardScaler()
X = scaler.fit_transform(df[nutritional_columns])
food_embeddings = train_model(X)

# --- Functions ---
def recommend_food_nn(food_name, dataset, embeddings, top_n=5):
    dataset['Food'] = dataset['Food'].str.lower()
    food_name = food_name.lower()
    idx = dataset[dataset['Food'] == food_name].index[0]
    vec = embeddings[idx].reshape(1, -1)
    sims = cosine_similarity(vec, embeddings).flatten()
    recommended_idx = sims.argsort()[::-1][1:top_n+1]
    return dataset.iloc[recommended_idx]['Food'].tolist()

def calculate_bmi(weight, height_cm):
    return weight / (height_cm/100)**2

def calculate_tdee(weight, height, age, sex, activity_level):
    if sex == 'male':
        bmr = 10*weight + 6.25*height - 5*age + 5
    else:
        bmr = 10*weight + 6.25*height - 5*age - 161
    multipliers = {'sedentary':1.2, 'light':1.375, 'moderate':1.55, 'active':1.725, 'superactive':1.9}
    return bmr * multipliers[activity_level]

# --- Meal Plan Logic ---
def generate_meal_plan(preferences, daily_calories):
    plan = []
    meal_split = {'breakfast':0.25, 'lunch':0.35, 'dinner':0.4}
    for day in range(1,8):
        day_plan = {'Day': f"Day {day}"}
        total_portion = 0
        for meal, portion in meal_split.items():
            starter_foods = preferences.get(meal, [])
            meal_foods = []
            for food in starter_foods:
                meal_foods += recommend_food_nn(food, df, food_embeddings, top_n=5)
            meal_foods = list(set(meal_foods))
            if not meal_foods:
                meal_foods = df['Food'].sample(2).tolist()

            selected = np.random.choice(meal_foods, 1)[0]
            cal = df[df['Food'] == selected]['Calories(100g)'].values[0]
            quantity = (daily_calories * portion) / cal * 100
            day_plan[meal.capitalize()] = f"{selected} ({quantity:.0f}g)"
            total_portion += quantity
        day_plan['Total Portion (g)'] = f"{total_portion:.0f}g"
        plan.append(day_plan)
    return pd.DataFrame(plan)

# --- Sidebar ---
st.sidebar.image('https://i.imgur.com/9JYvZq7.png', width=200)
st.sidebar.header("üéØ Your Details")

weight = st.sidebar.number_input("Current Weight (kg)", 30, 200, 90)
target_weight = st.sidebar.number_input("Target Weight (kg)", 30, 200, 75)
height = st.sidebar.number_input("Height (cm)", 120, 250, 160)
age = st.sidebar.number_input("Age", 10, 100, 25)
sex = st.sidebar.selectbox("Sex", ['female', 'male'])
activity_level = st.sidebar.selectbox("Activity Level", ['sedentary', 'light', 'moderate', 'active', 'superactive'])

st.sidebar.subheader("üçΩÔ∏è Select Foods You Like")
breakfast = st.sidebar.multiselect("Breakfast Options", df['Food'].unique())
lunch = st.sidebar.multiselect("Lunch Options", df['Food'].unique())
dinner = st.sidebar.multiselect("Dinner Options", df['Food'].unique())

# --- Main Section ---
if st.sidebar.button("‚ú® Generate Meal Plan") or "plan" not in st.session_state:
    bmi = calculate_bmi(weight, height)
    tdee = calculate_tdee(weight, height, age, sex, activity_level)
    st.session_state.target_calories = tdee - 500
    months = int(np.round((weight - target_weight) / 2))

    st.success(f"üéØ Target: {target_weight} kg ‚Ä¢ Estimated time: {months} months")
    st.info(f"üî• Daily Calorie Target: {st.session_state.target_calories:.0f} kcal/day")

    preferences = {
        'breakfast': breakfast,
        'lunch': lunch,
        'dinner': dinner
    }
    st.session_state.plan = generate_meal_plan(preferences, st.session_state.target_calories)


# --- Display Plan ---
if "plan" in st.session_state:
    st.subheader("ü•ó 7-Day Meal Plan")
    st.dataframe(st.session_state.plan, use_container_width=True)

    col1, col2 = st.columns(2)

    with col1:
        if st.button("üîÑ Reshuffle Plan"):
            preferences = {
                'breakfast': breakfast,
                'lunch': lunch,
                'dinner': dinner
            }
            st.session_state.plan = generate_meal_plan(preferences, st.session_state.target_calories)

            st.rerun()


    with col2:
        if st.button("‚è© Next Week's Plan"):
            preferences = {
                'breakfast': breakfast,
                'lunch': lunch,
                'dinner': dinner
            }
            st.session_state.plan = generate_meal_plan(preferences, st.session_state.target_calories)
            st.rerun()



'''

# Save it into 'app.py'
with open('app.py','w') as f:
    f.write(streamlit_app)

!ngrok config add-authtoken

# 3. Launch Streamlit + create tunnel
from pyngrok import ngrok
!pkill streamlit
public_url = ngrok.connect(addr="8501", proto="http")
print(public_url)
!streamlit run app.py --server.enableCORS false --server.enableXsrfProtection false